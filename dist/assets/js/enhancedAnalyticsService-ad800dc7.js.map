{"version":3,"file":"enhancedAnalyticsService-ad800dc7.js","sources":["../../../src/services/performanceMonitor.ts","../../../src/services/analyticsReliabilityService.ts","../../../src/services/enhancedAnalyticsService.ts"],"sourcesContent":["export interface PerformanceMetrics {\n  // Load time metrics\n  demoLoadTime: number;\n  featureGateResponseTime: number;\n  signupFlowCompletionTime: number;\n  audioLoadTime: number;\n  \n  // Session metrics\n  sessionDuration: number;\n  featureUsage: Record<string, number>;\n  interactionLatency: Record<string, number>;\n  \n  // Resource metrics\n  memoryUsage: number;\n  cpuUsage: number;\n  networkRequests: number;\n  \n  // User experience metrics\n  timeToInteractive: number;\n  firstContentfulPaint: number;\n  largestContentfulPaint: number;\n  \n  // Custom metrics\n  customMetrics: Record<string, number>;\n}\n\nexport interface PerformanceEvent {\n  metric: string;\n  value: number;\n  timestamp: number;\n  sessionId: string;\n  userId?: string;\n  userTier: string;\n  context: Record<string, any>;\n}\n\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor;\n  private metrics: Map<string, PerformanceMetrics> = new Map();\n  private observers: Map<string, PerformanceObserver> = new Map();\n  private analytics: any; // Will be imported from analyticsService\n  private isEnabled: boolean = false;\n  \n  private constructor() {\n    // Don't initialize observers immediately - wait for enable()\n  }\n  \n  static getInstance(): PerformanceMonitor {\n    if (!PerformanceMonitor.instance) {\n      PerformanceMonitor.instance = new PerformanceMonitor();\n    }\n    return PerformanceMonitor.instance;\n  }\n  \n  enable(): void {\n    if (this.isEnabled) return;\n    this.isEnabled = true;\n    this.initializeObservers();\n  }\n  \n  disable(): void {\n    if (!this.isEnabled) return;\n    this.isEnabled = false;\n    this.disposeObservers();\n  }\n  \n  private disposeObservers(): void {\n    this.observers.forEach(observer => observer.disconnect());\n    this.observers.clear();\n  }\n  \n  private initializeObservers(): void {\n    // Only initialize if PerformanceObserver is supported and enabled\n    if (!('PerformanceObserver' in window) || !this.isEnabled) return;\n    \n    try {\n      // Navigation timing\n      const navigationObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'navigation') {\n            this.handleNavigationTiming(entry as PerformanceNavigationTiming);\n          }\n        }\n      });\n      navigationObserver.observe({ entryTypes: ['navigation'] });\n      this.observers.set('navigation', navigationObserver);\n    } catch (error) {\n      console.warn('Failed to initialize navigation observer:', error);\n    }\n    \n    try {\n      // Paint timing\n      const paintObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'paint') {\n            this.handlePaintTiming(entry as PerformancePaintTiming);\n          }\n        }\n      });\n      paintObserver.observe({ entryTypes: ['paint'] });\n      this.observers.set('paint', paintObserver);\n    } catch (error) {\n      console.warn('Failed to initialize paint observer:', error);\n    }\n    \n    try {\n      // Resource timing - only for critical resources\n      const resourceObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'resource') {\n            this.handleResourceTiming(entry as PerformanceResourceTiming);\n          }\n        }\n      });\n      resourceObserver.observe({ entryTypes: ['resource'] });\n      this.observers.set('resource', resourceObserver);\n    } catch (error) {\n      console.warn('Failed to initialize resource observer:', error);\n    }\n  }\n  \n  private handleNavigationTiming(entry: PerformanceNavigationTiming): void {\n    const metrics = {\n      demoLoadTime: entry.loadEventEnd - entry.loadEventStart,\n      timeToInteractive: entry.domInteractive - entry.fetchStart,\n      firstContentfulPaint: entry.domContentLoadedEventEnd - entry.fetchStart\n    };\n    \n    this.trackMetrics('navigation', metrics);\n  }\n  \n  private handlePaintTiming(entry: PerformancePaintTiming): void {\n    if (entry.name === 'first-paint') {\n      this.trackMetric('firstPaint', entry.startTime);\n    } else if (entry.name === 'first-contentful-paint') {\n      this.trackMetric('firstContentfulPaint', entry.startTime);\n    }\n  }\n  \n  private handleResourceTiming(entry: PerformanceResourceTiming): void {\n    if (entry.name.includes('.wav') || entry.name.includes('.mp3')) {\n      this.trackMetric('audioLoadTime', entry.duration);\n    }\n  }\n  \n  trackMetric(metric: string, value: number, context: Record<string, any> = {}): void {\n    const event: PerformanceEvent = {\n      metric,\n      value,\n      timestamp: Date.now(),\n      sessionId: this.getSessionId(),\n      userId: this.getCurrentUserId(),\n      userTier: this.getCurrentUserTier(),\n      context\n    };\n    \n    // Store locally\n    this.storeMetric(event);\n    \n    // Send to analytics if available\n    if (this.analytics) {\n      this.analytics.track('performance_metric', event);\n    }\n  }\n  \n  trackMetrics(category: string, metrics: Record<string, number>, context: Record<string, any> = {}): void {\n    Object.entries(metrics).forEach(([metric, value]) => {\n      this.trackMetric(`${category}_${metric}`, value, context);\n    });\n  }\n  \n  startTimer(metric: string): () => void {\n    const startTime = performance.now();\n    return () => {\n      const duration = performance.now() - startTime;\n      this.trackMetric(metric, duration);\n    };\n  }\n  \n  private storeMetric(event: PerformanceEvent): void {\n    try {\n      const stored = JSON.parse(localStorage.getItem('performance_metrics') || '[]');\n      stored.push(event);\n      \n      // Keep only last 100 metrics\n      if (stored.length > 100) {\n        stored.splice(0, stored.length - 100);\n      }\n      \n      localStorage.setItem('performance_metrics', JSON.stringify(stored));\n    } catch (error) {\n      console.error('Failed to store performance metric:', error);\n    }\n  }\n  \n  private getCurrentUserId(): string | undefined {\n    return localStorage.getItem('user_id') || undefined;\n  }\n  \n  private getCurrentUserTier(): string {\n    return localStorage.getItem('user_tier') || 'guest';\n  }\n  \n  private getSessionId(): string {\n    return localStorage.getItem('session_id') || `session_${Date.now()}`;\n  }\n  \n  getMetrics(): PerformanceEvent[] {\n    try {\n      return JSON.parse(localStorage.getItem('performance_metrics') || '[]');\n    } catch (error) {\n      console.error('Failed to get performance metrics:', error);\n      return [];\n    }\n  }\n  \n  clearMetrics(): void {\n    try {\n      localStorage.removeItem('performance_metrics');\n    } catch (error) {\n      console.error('Failed to clear performance metrics:', error);\n    }\n  }\n  \n  // Set analytics service reference\n  setAnalyticsService(analytics: any): void {\n    this.analytics = analytics;\n  }\n} ","export interface AnalyticsEvent {\n  event: string;\n  properties: Record<string, any>;\n  timestamp: number;\n  sessionId: string;\n  userId?: string;\n  userTier: string;\n  retryCount: number;\n  maxRetries: number;\n}\n\nexport class AnalyticsReliabilityService {\n  private static instance: AnalyticsReliabilityService;\n  private pendingEvents: AnalyticsEvent[] = [];\n  private isOnline: boolean = navigator.onLine;\n  private retryInterval: number = 5000; // 5 seconds\n  private maxRetries: number = 3;\n  private retryTimer?: NodeJS.Timeout;\n  \n  private constructor() {\n    this.loadPendingEvents();\n    this.setupNetworkListeners();\n    this.startRetryTimer();\n  }\n  \n  static getInstance(): AnalyticsReliabilityService {\n    if (!AnalyticsReliabilityService.instance) {\n      AnalyticsReliabilityService.instance = new AnalyticsReliabilityService();\n    }\n    return AnalyticsReliabilityService.instance;\n  }\n  \n  private setupNetworkListeners(): void {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.processPendingEvents();\n    });\n    \n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n  }\n  \n  private startRetryTimer(): void {\n    this.retryTimer = setInterval(() => {\n      if (this.isOnline && this.pendingEvents.length > 0) {\n        this.processPendingEvents();\n      }\n    }, this.retryInterval);\n  }\n  \n  queueEvent(event: string, properties: Record<string, any>): void {\n    const analyticsEvent: AnalyticsEvent = {\n      event,\n      properties,\n      timestamp: Date.now(),\n      sessionId: this.getSessionId(),\n      userId: this.getCurrentUserId(),\n      userTier: this.getCurrentUserTier(),\n      retryCount: 0,\n      maxRetries: this.maxRetries\n    };\n    \n    this.pendingEvents.push(analyticsEvent);\n    this.savePendingEvents();\n    \n    // Try to send immediately if online\n    if (this.isOnline) {\n      this.processPendingEvents();\n    }\n  }\n  \n  private async processPendingEvents(): Promise<void> {\n    const eventsToProcess = [...this.pendingEvents];\n    \n    for (const event of eventsToProcess) {\n      try {\n        await this.sendEvent(event);\n        \n        // Remove successfully sent event\n        this.pendingEvents = this.pendingEvents.filter(e => e !== event);\n        this.savePendingEvents();\n        \n      } catch (error) {\n        event.retryCount++;\n        \n        // Remove events that have exceeded max retries\n        if (event.retryCount >= event.maxRetries) {\n          this.pendingEvents = this.pendingEvents.filter(e => e !== event);\n          this.savePendingEvents();\n          \n          console.error(`Failed to send analytics event after ${event.maxRetries} retries:`, event);\n        }\n      }\n    }\n  }\n  \n  private async sendEvent(event: AnalyticsEvent): Promise<void> {\n    // For now, we'll use a mock API endpoint\n    // In production, this would be your actual analytics API\n    const response = await fetch('/api/analytics', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(event)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Analytics API returned ${response.status}`);\n    }\n  }\n  \n  private loadPendingEvents(): void {\n    try {\n      const stored = localStorage.getItem('pending_analytics_events');\n      if (stored) {\n        this.pendingEvents = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('Failed to load pending analytics events:', error);\n      this.pendingEvents = [];\n    }\n  }\n  \n  private savePendingEvents(): void {\n    try {\n      localStorage.setItem('pending_analytics_events', JSON.stringify(this.pendingEvents));\n    } catch (error) {\n      console.error('Failed to save pending analytics events:', error);\n    }\n  }\n  \n  private getSessionId(): string {\n    return localStorage.getItem('session_id') || `session_${Date.now()}`;\n  }\n  \n  private getCurrentUserId(): string | undefined {\n    return localStorage.getItem('user_id') || undefined;\n  }\n  \n  private getCurrentUserTier(): string {\n    return localStorage.getItem('user_tier') || 'guest';\n  }\n  \n  getPendingEventCount(): number {\n    return this.pendingEvents.length;\n  }\n  \n  clearPendingEvents(): void {\n    this.pendingEvents = [];\n    this.savePendingEvents();\n  }\n  \n  // Cleanup method\n  destroy(): void {\n    if (this.retryTimer) {\n      clearInterval(this.retryTimer);\n    }\n  }\n} ","import { PerformanceMonitor } from './performanceMonitor';\nimport { ErrorMonitor } from './errorMonitor';\nimport { AnalyticsReliabilityService } from './analyticsReliabilityService';\nimport { AnalyticsService } from './analyticsService';\n\nexport class EnhancedAnalyticsService {\n  private static instance: EnhancedAnalyticsService;\n  private reliabilityService: AnalyticsReliabilityService | null = null;\n  private performanceMonitor: PerformanceMonitor | null = null;\n  private errorMonitor: ErrorMonitor | null = null;\n  private analyticsService: AnalyticsService | null = null;\n  private isInitialized: boolean = false;\n  \n  private constructor() {\n    // Don't initialize services immediately\n  }\n  \n  static getInstance(): EnhancedAnalyticsService {\n    if (!EnhancedAnalyticsService.instance) {\n      EnhancedAnalyticsService.instance = new EnhancedAnalyticsService();\n    }\n    return EnhancedAnalyticsService.instance;\n  }\n  \n  private async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    \n    // Lazy load services\n    this.reliabilityService = AnalyticsReliabilityService.getInstance();\n    this.performanceMonitor = PerformanceMonitor.getInstance();\n    this.errorMonitor = ErrorMonitor.getInstance();\n    this.analyticsService = AnalyticsService.getInstance();\n    \n    // Only enable performance monitoring in development or when explicitly requested\n    if (process.env.NODE_ENV === 'development') {\n      this.performanceMonitor.enable();\n    }\n    \n    // Set up cross-service references\n    if (this.performanceMonitor) {\n      this.performanceMonitor.setAnalyticsService(this);\n    }\n    if (this.errorMonitor) {\n      this.errorMonitor.setAnalyticsService(this);\n    }\n    \n    this.isInitialized = true;\n  }\n  \n  async track(event: string, properties: Record<string, any> = {}): Promise<void> {\n    await this.initialize();\n    \n    // Add common properties\n    const enhancedProperties = {\n      ...properties,\n      timestamp: Date.now(),\n      sessionId: this.getSessionId(),\n      userId: this.getCurrentUserId(),\n      userTier: this.getCurrentUserTier(),\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      screenSize: `${screen.width}x${screen.height}`,\n      viewportSize: `${window.innerWidth}x${window.innerHeight}`,\n      networkStatus: navigator.onLine ? 'online' : 'offline'\n    };\n    \n    // Queue event for reliable delivery\n    if (this.reliabilityService) {\n      this.reliabilityService.queueEvent(event, enhancedProperties);\n    }\n    \n    // Track performance impact\n    if (this.performanceMonitor) {\n      this.performanceMonitor.trackMetric('analytics_event_sent', 1, { event });\n    }\n  }\n  \n  async trackPerformance(metric: string, value: number, context: Record<string, any> = {}): Promise<void> {\n    await this.initialize();\n    if (this.performanceMonitor) {\n      this.performanceMonitor.trackMetric(metric, value, context);\n    }\n  }\n  \n  async trackError(error: Error, context: string, additionalContext: Record<string, any> = {}): Promise<void> {\n    await this.initialize();\n    if (this.errorMonitor) {\n      this.errorMonitor.captureError(error, context, additionalContext);\n    }\n  }\n  \n  async trackCustomError(message: string, context: string, severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'): Promise<void> {\n    await this.initialize();\n    if (this.errorMonitor) {\n      this.errorMonitor.captureCustomError(message, context, severity);\n    }\n  }\n  \n  async startPerformanceTimer(metric: string): Promise<() => void> {\n    await this.initialize();\n    if (this.performanceMonitor) {\n      return this.performanceMonitor.startTimer(metric);\n    }\n    return () => {}; // No-op if not initialized\n  }\n  \n  getSessionId(): string {\n    return localStorage.getItem('session_id') || `session_${Date.now()}`;\n  }\n  \n  private getCurrentUserId(): string | undefined {\n    return localStorage.getItem('user_id') || undefined;\n  }\n  \n  private getCurrentUserTier(): string {\n    return localStorage.getItem('user_tier') || 'guest';\n  }\n  \n  // Health check methods\n  getHealthStatus(): {\n    pendingEvents: number;\n    errorRate: number;\n    isOnline: boolean;\n    lastError?: any;\n    performanceMetrics: any[];\n  } {\n    return {\n      pendingEvents: this.reliabilityService?.getPendingEventCount() || 0,\n      errorRate: this.errorMonitor?.getErrorRate() || 0,\n      isOnline: navigator.onLine,\n      lastError: this.errorMonitor?.getErrors()[this.errorMonitor?.getErrors().length - 1],\n      performanceMetrics: this.performanceMonitor?.getMetrics() || []\n    };\n  }\n  \n  // Get monitoring data\n  getPerformanceMetrics() {\n    return this.performanceMonitor?.getMetrics() || [];\n  }\n  \n  getErrors() {\n    return this.errorMonitor?.getErrors() || [];\n  }\n  \n  // Clear monitoring data\n  clearPerformanceMetrics() {\n    this.performanceMonitor?.clearMetrics();\n  }\n  \n  clearErrors() {\n    this.errorMonitor?.clearErrors();\n  }\n  \n  clearPendingEvents() {\n    this.reliabilityService?.clearPendingEvents();\n  }\n  \n  // Cleanup\n  destroy(): void {\n    this.reliabilityService?.destroy();\n  }\n} "],"names":["PerformanceMonitor","static","metrics","Map","observers","analytics","isEnabled","constructor","getInstance","instance","enable","this","initializeObservers","disable","disposeObservers","forEach","observer","disconnect","clear","window","navigationObserver","PerformanceObserver","list","entry","getEntries","entryType","handleNavigationTiming","observe","entryTypes","set","error","paintObserver","handlePaintTiming","resourceObserver","handleResourceTiming","demoLoadTime","loadEventEnd","loadEventStart","timeToInteractive","domInteractive","fetchStart","firstContentfulPaint","domContentLoadedEventEnd","trackMetrics","name","trackMetric","startTime","includes","duration","metric","value","context","event","timestamp","Date","now","sessionId","getSessionId","userId","getCurrentUserId","userTier","getCurrentUserTier","storeMetric","track","category","Object","entries","startTimer","performance","stored","JSON","parse","localStorage","getItem","push","length","splice","setItem","stringify","getMetrics","clearMetrics","removeItem","setAnalyticsService","AnalyticsReliabilityService","pendingEvents","isOnline","navigator","onLine","retryInterval","maxRetries","retryTimer","loadPendingEvents","setupNetworkListeners","startRetryTimer","addEventListener","processPendingEvents","setInterval","queueEvent","properties","analyticsEvent","retryCount","savePendingEvents","eventsToProcess","sendEvent","filter","e","response","fetch","method","headers","body","ok","Error","status","getPendingEventCount","clearPendingEvents","destroy","clearInterval","EnhancedAnalyticsService","reliabilityService","performanceMonitor","errorMonitor","analyticsService","isInitialized","initialize","ErrorMonitor","AnalyticsService","enhancedProperties","url","location","href","userAgent","screenSize","screen","width","height","viewportSize","innerWidth","innerHeight","networkStatus","trackPerformance","trackError","additionalContext","captureError","trackCustomError","message","severity","captureCustomError","startPerformanceTimer","getHealthStatus","errorRate","getErrorRate","lastError","getErrors","performanceMetrics","getPerformanceMetrics","clearPerformanceMetrics","clearErrors"],"mappings":"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"}