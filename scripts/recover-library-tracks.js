import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";

dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.VITE_SUPABASE_SERVICE_ROLE_KEY ||
    process.env.VITE_SUPABASE_ANON_KEY
);

class LibraryTrackRecovery {
  constructor() {
    this.supabase = supabase;
  }

  /**
   * List all tracks in Supabase storage
   */
  async listStorageTracks() {
    try {
      const { data, error } = await this.supabase.storage
        .from("library-tracks")
        .list("");

      if (error) {
        console.error("Error listing storage tracks:", error);
        return [];
      }

      console.log("\nüìÅ Tracks in Supabase Storage:");
      data.forEach((file, index) => {
        console.log(`  ${index + 1}. ${file.name}`);
      });

      return data || [];
    } catch (error) {
      console.error("Error listing storage tracks:", error);
      return [];
    }
  }

  /**
   * Extract basic track info from filename
   */
  extractTrackInfo(filename) {
    // Remove file extension
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, "");

    // Try to extract genre/key info from filename
    let genre = "electronic"; // default
    let key = null;

    // Common genre patterns
    if (nameWithoutExt.toLowerCase().includes("drum")) {
      genre = "drum-n-bass";
    } else if (nameWithoutExt.toLowerCase().includes("house")) {
      genre = "house";
    } else if (nameWithoutExt.toLowerCase().includes("techno")) {
      genre = "techno";
    } else if (nameWithoutExt.toLowerCase().includes("ambient")) {
      genre = "ambient";
    }

    // Common key patterns
    const keyMatch = nameWithoutExt.match(/([A-G][#b]?m?)/i);
    if (keyMatch) {
      key = keyMatch[1];
    }

    return {
      trackId: this.slugify(nameWithoutExt),
      name: nameWithoutExt,
      artist: "Generated by Audafact",
      genre: genre,
      key: key,
      fileName: filename,
      type: filename.split(".").pop().toLowerCase(),
      isProOnly: false,
      rotationWeek: 1,
    };
  }

  /**
   * Create URL-friendly slug
   */
  slugify(text) {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  /**
   * Re-create database records for all tracks
   */
  async recreateDatabaseRecords(storageTracks) {
    console.log("\nüîÑ Re-creating database records...");

    let successCount = 0;
    const totalCount = storageTracks.length;

    for (const track of storageTracks) {
      try {
        const trackInfo = this.extractTrackInfo(track.name);

        // Get storage URL
        const storageUrl = this.supabase.storage
          .from("library-tracks")
          .getPublicUrl(track.name);

        // Insert or update database record
        const { error } = await this.supabase.from("library_tracks").upsert(
          {
            track_id: trackInfo.trackId,
            name: trackInfo.name,
            artist: trackInfo.artist,
            genre: trackInfo.genre,
            bpm: 128, // Default BPM - you can update this later
            key: trackInfo.key || "Am", // Default key if none detected
            duration: 180, // Default duration - you can update this later
            file_url: storageUrl.data.publicUrl,
            type: trackInfo.type,
            size: track.metadata?.size || "Unknown",
            tags: [trackInfo.genre, "recovered"],
            is_pro_only: trackInfo.isProOnly,
            preview_url: null,
            rotation_week: trackInfo.rotationWeek,
            is_active: true,
          },
          {
            onConflict: "track_id",
          }
        );

        if (error) {
          console.error(
            `‚ùå Failed to create record for ${trackInfo.name}:`,
            error
          );
        } else {
          console.log(`‚úÖ Created/updated record for ${trackInfo.name}`);
          successCount++;
        }
      } catch (error) {
        console.error(`‚ùå Error processing ${track.name}:`, error);
      }
    }

    console.log(`\nüìä Recovery Summary:`);
    console.log(
      `‚úÖ Successfully processed: ${successCount}/${totalCount} tracks`
    );

    return successCount;
  }

  /**
   * Main recovery process
   */
  async recover() {
    console.log("üöÄ Starting Library Track Recovery...\n");

    // List storage tracks
    const storageTracks = await this.listStorageTracks();
    if (storageTracks.length === 0) {
      console.log("‚ùå No tracks found in storage");
      return;
    }

    // Re-create database records
    await this.recreateDatabaseRecords(storageTracks);

    console.log("\nüéâ Recovery process completed!");
    console.log("\nüìù Next steps:");
    console.log("1. Review the created records in your database");
    console.log("2. Update BPM, key, and duration for each track");
    console.log("3. Add proper tags and metadata");
    console.log("4. Test that tracks are accessible through your API");
  }
}

// CLI interface
async function main() {
  const recovery = new LibraryTrackRecovery();
  const command = process.argv[2];

  try {
    switch (command) {
      case "recover":
        await recovery.recover();
        break;

      case "list-storage":
        await recovery.listStorageTracks();
        break;

      default:
        console.log(`
Library Track Recovery Tool

Usage:
  node recover-library-tracks.js recover      - Recover all library tracks
  node recover-library-tracks.js list-storage - List tracks in Supabase storage

Prerequisites:
  1. Ensure your .env file has VITE_SUPABASE_URL and VITE_SUPABASE_SERVICE_ROLE_KEY
  2. Make sure your Supabase storage has the audio files
        `);
    }
  } catch (error) {
    console.error("Error:", error.message);
  }
}

// Check if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export default LibraryTrackRecovery;
